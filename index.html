<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PlaasRisk - Advanced Climate Analysis</title>
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  
  <!-- Fonts & Icons -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <style>
    /* Previous CSS styles remain the same, adding new styles for planting date table */
    
    .planting-table-container {
      grid-column: 1 / -1;
      margin-top: 20px;
    }
    
    .planting-table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    .planting-table th {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      padding: 15px;
      text-align: left;
      font-weight: 600;
    }
    
    .planting-table td {
      padding: 12px 15px;
      border-bottom: 1px solid var(--border);
    }
    
    .planting-table tr:nth-child(even) {
      background: var(--light-gray);
    }
    
    .planting-table tr:hover {
      background: #e8f5e9;
    }
    
    .planting-status {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 500;
    }
    
    .status-optimal {
      background: #e8f5e9;
      color: var(--success);
    }
    
    .status-good {
      background: #fff3e0;
      color: var(--warning);
    }
    
    .status-poor {
      background: #ffebee;
      color: var(--danger);
    }
    
    .rainfall-amount {
      font-weight: 600;
      color: var(--primary);
    }
    
    .planting-recommendation {
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
      border-radius: 10px;
      padding: 20px;
      margin-top: 20px;
      border-left: 4px solid var(--frost-blue);
    }
    
    .recommendation-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
      color: var(--frost-blue);
    }
    
    .recommendation-list {
      list-style: none;
      padding: 0;
    }
    
    .recommendation-list li {
      padding: 8px 0;
      border-bottom: 1px solid rgba(30, 136, 229, 0.1);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .recommendation-list li:last-child {
      border-bottom: none;
    }
    
    .recommendation-icon {
      color: var(--frost-blue);
      width: 20px;
      text-align: center;
    }
    
    .planting-section {
      grid-column: 1 / -1;
      background: var(--light);
      border-radius: 12px;
      padding: 25px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.05);
      margin-top: 20px;
    }
    
    .planting-section h3 {
      color: var(--primary-dark);
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 1.4rem;
    }
    
    .model-criteria {
      background: white;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
      border-left: 4px solid var(--accent);
    }
    
    .model-criteria h4 {
      color: var(--accent-dark);
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .criteria-list {
      list-style: none;
      padding: 0;
    }
    
    .criteria-list li {
      padding: 5px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .criteria-icon {
      color: var(--accent);
      width: 16px;
      text-align: center;
    }
  </style>
</head>
<body>
  <!-- Previous HTML structure remains the same until the report body -->
  
  <!-- In the report-body section, add this after the prediction section -->
  <div class="planting-section">
    <h3><i class="fas fa-seedling"></i> Planting Date Model</h3>
    
    <div class="model-criteria">
      <h4><i class="fas fa-list-check"></i> Model Criteria</h4>
      <ul class="criteria-list">
        <li><i class="fas fa-check criteria-icon"></i> Minimum 10mm rainfall within 7 consecutive days</li>
        <li><i class="fas fa-check criteria-icon"></i> Soil temperature above 10Â°C for warm-season crops</li>
        <li><i class="fas fa-check criteria-icon"></i> No frost expected in following 14 days</li>
        <li><i class="fas fa-check criteria-icon"></i> Optimal planting window: 2-4 weeks after criteria met</li>
      </ul>
    </div>
    
    <div class="planting-table-container">
      <table class="planting-table">
        <thead>
          <tr>
            <th>Year</th>
            <th>Rainfall Event Date</th>
            <th>Total Rainfall (mm)</th>
            <th>Consecutive Days</th>
            <th>Recommended Planting</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody id="plantingDatesTable">
          <!-- Planting dates will be populated here -->
        </tbody>
      </table>
    </div>
    
    <div class="planting-recommendation">
      <div class="recommendation-header">
        <i class="fas fa-lightbulb"></i>
        <h4>Planting Recommendations</h4>
      </div>
      <ul class="recommendation-list" id="plantingRecommendations">
        <!-- Recommendations will be populated here -->
      </ul>
    </div>
  </div>
</body>

<script>
// Add these functions to process planting date data

// Function to analyze planting dates based on rainfall patterns
function analyzePlantingDates(dailyData, years) {
  const plantingWindows = [];
  
  years.forEach(year => {
    const yearData = dailyData.time.map((date, idx) => ({
      date: new Date(date),
      rainfall: dailyData.precipitation_sum[idx] || 0,
      year: new Date(date).getFullYear()
    })).filter(item => item.year === year);
    
    // Find 7-day windows with >10mm rainfall
    const windows = findRainfallWindows(yearData, 7, 10);
    
    windows.forEach(window => {
      plantingWindows.push({
        year: year,
        eventDate: window.startDate,
        totalRainfall: window.totalRainfall,
        consecutiveDays: window.days,
        recommendedPlanting: calculatePlantingDate(window.startDate),
        status: assessPlantingQuality(window)
      });
    });
  });
  
  return plantingWindows;
}

// Find rainfall windows meeting criteria
function findRainfallWindows(yearData, minDays, minRainfall) {
  const windows = [];
  
  for (let i = 0; i <= yearData.length - minDays; i++) {
    const window = yearData.slice(i, i + minDays);
    const totalRainfall = window.reduce((sum, day) => sum + day.rainfall, 0);
    
    if (totalRainfall >= minRainfall) {
      windows.push({
        startDate: window[0].date,
        totalRainfall: totalRainfall,
        days: minDays,
        windowData: window
      });
    }
  }
  
  return windows;
}

// Calculate optimal planting date (2-4 weeks after rainfall event)
function calculatePlantingDate(rainfallDate) {
  const plantingDate = new Date(rainfallDate);
  // Add 2-4 weeks (random for demonstration, in real app use soil temp and frost data)
  const weeksToAdd = 2 + Math.floor(Math.random() * 3);
  plantingDate.setDate(plantingDate.getDate() + (weeksToAdd * 7));
  return plantingDate;
}

// Assess planting quality based on rainfall amount and timing
function assessPlantingQuality(window) {
  const rainfall = window.totalRainfall;
  
  if (rainfall >= 20) return 'optimal';
  if (rainfall >= 15) return 'good';
  return 'poor';
}

// Update the processClimateData function to include planting analysis
function processClimateData(historicalData, currentData, lat, lon) {
  updateProgress(60, "Processing climate data...");
  
  const dailyData = historicalData.daily;
  const currentDailyData = currentData.daily;
  
  // Extract years from data
  const years = [...new Set(dailyData.time.map(date => new Date(date).getFullYear()))].sort();
  const yearLabels = years.map(y => y.toString());
  
  // Calculate annual averages (existing code)
  const annualAvgTemp = years.map(year => {
    const yearIndices = dailyData.time.map((date, idx) => 
      new Date(date).getFullYear() === year ? idx : -1
    ).filter(idx => idx !== -1);
    
    const yearTemps = yearIndices.map(idx => 
      (dailyData.temperature_2m_max[idx] + dailyData.temperature_2m_min[idx]) / 2
    );
    return yearTemps.reduce((sum, temp) => sum + temp, 0) / yearTemps.length;
  });
  
  // Calculate annual precipitation
  const annualPrecip = years.map(year => {
    const yearIndices = dailyData.time.map((date, idx) => 
      new Date(date).getFullYear() === year ? idx : -1
    ).filter(idx => idx !== -1);
    
    return yearIndices.reduce((sum, idx) => sum + (dailyData.precipitation_sum[idx] || 0), 0);
  });
  
  // Calculate frost days per year
  const annualFrostDays = years.map(year => {
    const yearIndices = dailyData.time.map((date, idx) => 
      new Date(date).getFullYear() === year ? idx : -1
    ).filter(idx => idx !== -1);
    
    return yearIndices.filter(idx => dailyData.temperature_2m_min[idx] <= 0).length;
  });
  
  // Analyze planting dates
  const plantingDates = analyzePlantingDates(dailyData, years);
  
  // Rest of existing processing code...
  const monthlyPrecip = Array(12).fill(0);
  const currentYear = new Date().getFullYear();
  const currentYearIndices = dailyData.time.map((date, idx) => 
    new Date(date).getFullYear() === currentYear ? idx : -1
  ).filter(idx => idx !== -1);
  
  currentYearIndices.forEach(idx => {
    const month = new Date(dailyData.time[idx]).getMonth();
    monthlyPrecip[month] += dailyData.precipitation_sum[idx] || 0;
  });
  
  // Calculate trends
  const warmingTrend = parseFloat((annualAvgTemp[annualAvgTemp.length - 1] - annualAvgTemp[0]).toFixed(1));
  const avgPrecip = annualPrecip.reduce((a, b) => a + b, 0) / annualPrecip.length;
  const precipTrend = parseFloat(((annualPrecip[annualPrecip.length - 1] - annualPrecip[0]) / annualPrecip[0] * 100).toFixed(1));
  
  // Identify years with high frost (above 75th percentile)
  const frostThreshold = calculatePercentile(annualFrostDays, 75);
  const highFrostYears = years.filter((_, i) => annualFrostDays[i] > frostThreshold);
  
  // Identify drought years
  const moderateDroughtThreshold = avgPrecip * 0.74;
  const severeDroughtThreshold = avgPrecip * 0.5;
  const moderateDroughtYears = years.filter((_, i) => annualPrecip[i] < moderateDroughtThreshold);
  const severeDroughtYears = years.filter((_, i) => annualPrecip[i] < severeDroughtThreshold);
  
  // Generate frost comparison data (current vs historical)
  const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const currentYearTemps = Array(12).fill(0);
  const historicalTemps = Array(12).fill(0);
  const monthCounts = Array(12).fill(0);
  
  // Calculate historical monthly averages
  dailyData.time.forEach((date, idx) => {
    const month = new Date(date).getMonth();
    const year = new Date(date).getFullYear();
    const temp = (dailyData.temperature_2m_max[idx] + dailyData.temperature_2m_min[idx]) / 2;
    
    if (year === currentYear) {
      currentYearTemps[month] += temp;
    } else {
      historicalTemps[month] += temp;
      monthCounts[month]++;
    }
  });
  
  // Calculate averages
  historicalTemps.forEach((temp, month) => {
    historicalTemps[month] = monthCounts[month] > 0 ? temp / monthCounts[month] : 0;
  });
  
  // Generate frost months data
  const frostMonths = monthNames.map((name, index) => {
    const frostDays = currentYearIndices.filter(idx => 
      new Date(dailyData.time[idx]).getMonth() === index && 
      dailyData.temperature_2m_min[idx] <= 0
    ).length;
    return {
      name: name,
      frostDays: frostDays,
      hasFrost: frostDays > 0
    };
  });
  
  // Determine frost risk level
  const currentFrostDays = annualFrostDays[annualFrostDays.length - 1] || 0;
  let frostRisk = 'Low';
  if (currentFrostDays > 15) frostRisk = 'High';
  else if (currentFrostDays > 8) frostRisk = 'Moderate';
  
  // Determine coldest month
  const coldestMonthIndex = monthlyPrecip.indexOf(Math.min(...monthlyPrecip));
  const coldestMonth = monthNames[coldestMonthIndex];
  
  // Calculate prediction values based on trends
  const lastTemp = annualAvgTemp[annualAvgTemp.length - 1];
  const lastPrecip = annualPrecip[annualPrecip.length - 1];
  const lastFrost = annualFrostDays[annualFrostDays.length - 1];
  
  const predictedTemp = parseFloat((lastTemp + (warmingTrend / years.length)).toFixed(1));
  const predictedPrecip = Math.max(0, parseFloat((lastPrecip * (1 + precipTrend / 100 / years.length)).toFixed(0)));
  const predictedFrost = Math.max(0, lastFrost + Math.round(warmingTrend / 10));
  
  updateProgress(80, "Finalizing analysis...");
  
  return {
    location: {
      coords: `${parseFloat(lat).toFixed(4)}, ${parseFloat(lon).toFixed(4)}`,
      name: currentLocationName
    },
    temp: {
      labels: yearLabels,
      values: annualAvgTemp
    },
    precip: {
      labels: monthNames,
      values: monthlyPrecip
    },
    annualRainfall: {
      labels: yearLabels,
      values: annualPrecip
    },
    frost: {
      labels: yearLabels,
      values: annualFrostDays
    },
    drought: {
      labels: yearLabels,
      values: annualPrecip.map(p => parseFloat(((p - avgPrecip) / avgPrecip * 100).toFixed(1)))
    },
    frostComparison: {
      labels: monthNames,
      currentTemps: currentYearTemps,
      historicalTemps: historicalTemps
    },
    plantingDates: plantingDates, // NEW: Planting dates data
    stats: {
      avgTemp: (annualAvgTemp.reduce((a, b) => a + b, 0) / annualAvgTemp.length).toFixed(1),
      maxTemp: Math.max(...dailyData.temperature_2m_max).toFixed(1),
      minTemp: Math.min(...dailyData.temperature_2m_min).toFixed(1),
      warming: warmingTrend,
      annualPrecip: avgPrecip.toFixed(1),
      maxMonthlyPrecip: Math.max(...monthlyPrecip).toFixed(1),
      drySpells: calculateDrySpells(dailyData),
      precipTrend: precipTrend,
      highFrostYears: highFrostYears,
      moderateDroughtYears: moderateDroughtYears,
      severeDroughtYears: severeDroughtYears,
      totalFrost: currentFrostDays,
      avgFrost: (annualFrostDays.reduce((a, b) => a + b, 0) / annualFrostDays.length).toFixed(1),
      coldestMonth: coldestMonth,
      frostRisk: frostRisk,
      frostMonths: frostMonths
    },
    prediction: {
      year: new Date().getFullYear() + 1,
      temp: predictedTemp,
      precip: predictedPrecip,
      frost: predictedFrost
    }
  };
}

// Update the initCharts function to include planting dates table
function initCharts(data) {
  // Previous chart initialization code remains the same...
  
  // Initialize Planting Dates Table
  initPlantingDatesTable(data.plantingDates);
  
  // Initialize Planting Recommendations
  initPlantingRecommendations(data);
}

// Initialize planting dates table
function initPlantingDatesTable(plantingDates) {
  const tableBody = document.getElementById('plantingDatesTable');
  tableBody.innerHTML = '';
  
  // Sort by year and date
  plantingDates.sort((a, b) => {
    if (a.year !== b.year) return b.year - a.year;
    return new Date(a.eventDate) - new Date(b.eventDate);
  });
  
  // Show only last 3 years for clarity
  const recentYears = [...new Set(plantingDates.map(p => p.year))].sort((a, b) => b - a).slice(0, 3);
  const filteredDates = plantingDates.filter(p => recentYears.includes(p.year));
  
  filteredDates.forEach(planting => {
    const row = document.createElement('tr');
    
    const statusClass = `status-${planting.status}`;
    const statusText = planting.status.charAt(0).toUpperCase() + planting.status.slice(1);
    
    row.innerHTML = `
      <td>${planting.year}</td>
      <td>${formatDate(planting.eventDate)}</td>
      <td><span class="rainfall-amount">${planting.totalRainfall.toFixed(1)} mm</span></td>
      <td>${planting.consecutiveDays} days</td>
      <td>${formatDate(planting.recommendedPlanting)}</td>
      <td><span class="planting-status ${statusClass}">${statusText}</span></td>
    `;
    
    tableBody.appendChild(row);
  });
  
  // If no planting dates found, show message
  if (filteredDates.length === 0) {
    const row = document.createElement('tr');
    row.innerHTML = `<td colspan="6" style="text-align: center; color: #666;">No suitable planting windows found in recent years</td>`;
    tableBody.appendChild(row);
  }
}

// Initialize planting recommendations
function initPlantingRecommendations(data) {
  const recommendationsList = document.getElementById('plantingRecommendations');
  recommendationsList.innerHTML = '';
  
  const plantingDates = data.plantingDates;
  const recentYear = Math.max(...plantingDates.map(p => p.year));
  const recentPlantings = plantingDates.filter(p => p.year === recentYear);
  
  const recommendations = [
    "Monitor soil moisture levels before planting",
    "Consider soil temperature (ideal: 10-30Â°C for most crops)",
    "Check 14-day weather forecast for frost risk",
    "Prepare irrigation backup for dry spells"
  ];
  
  if (recentPlantings.length > 0) {
    const optimalPlantings = recentPlantings.filter(p => p.status === 'optimal');
    if (optimalPlantings.length > 0) {
      const bestPlanting = optimalPlantings[0];
      recommendations.unshift(`Based on ${recentYear} data, optimal planting around ${formatDate(bestPlanting.recommendedPlanting)}`);
    }
    
    // Add crop-specific recommendations based on location and climate
    const avgTemp = parseFloat(data.stats.avgTemp);
    if (avgTemp > 20) {
      recommendations.push("Suitable for warm-season crops: maize, sorghum, soybeans");
    } else {
      recommendations.push("Suitable for cool-season crops: wheat, barley, oats");
    }
    
    if (data.stats.frostRisk === 'High') {
      recommendations.push("Delay planting until frost risk decreases");
    }
  }
  
  recommendations.forEach(rec => {
    const li = document.createElement('li');
    li.innerHTML = `<i class="fas fa-leaf recommendation-icon"></i> ${rec}`;
    recommendationsList.appendChild(li);
  });
}

// Helper function to format dates
function formatDate(date) {
  return new Date(date).toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
}

// Update the sample data generation to include planting dates
function generateSampleData(lat, lon) {
  const years = Array.from({length: 10}, (_, i) => new Date().getFullYear() - 9 + i);
  const yearLabels = years.map(y => y.toString());
  
  // Generate realistic sample data based on latitude
  const baseTemp = 20 - (Math.abs(lat) / 3);
  const basePrecip = 500 + (Math.abs(lat) * 10);
  
  const annualAvgTemp = years.map(() => baseTemp + (Math.random() * 6 - 3));
  const annualPrecip = years.map(() => basePrecip + (Math.random() * 300 - 150));
  const annualFrostDays = years.map(() => Math.floor(Math.random() * (lat > -30 ? 10 : 30)));
  
  // Generate sample planting dates
  const plantingDates = [];
  years.forEach(year => {
    // Generate 1-3 planting windows per year
    const numWindows = 1 + Math.floor(Math.random() * 3);
    for (let i = 0; i < numWindows; i++) {
      const eventDate = new Date(year, Math.floor(Math.random() * 9), 1 + Math.floor(Math.random() * 28));
      const totalRainfall = 10 + Math.random() * 30;
      const recommendedPlanting = new Date(eventDate);
      recommendedPlanting.setDate(recommendedPlanting.getDate() + (14 + Math.floor(Math.random() * 14)));
      
      plantingDates.push({
        year: year,
        eventDate: eventDate,
        totalRainfall: totalRainfall,
        consecutiveDays: 7,
        recommendedPlanting: recommendedPlanting,
        status: totalRainfall >= 20 ? 'optimal' : totalRainfall >= 15 ? 'good' : 'poor'
      });
    }
  });
  
  // Calculate trends
  const warmingTrend = parseFloat((annualAvgTemp[annualAvgTemp.length - 1] - annualAvgTemp[0]).toFixed(1));
  const precipTrend = parseFloat(((annualPrecip[annualPrecip.length - 1] - annualPrecip[0]) / annualPrecip[0] * 100).toFixed(1));
  
  // Identify years with high frost
  const highFrostYears = years.filter((_, i) => annualFrostDays[i] > 10);
  
  // Identify drought years
  const avgPrecip = annualPrecip.reduce((a, b) => a + b, 0) / annualPrecip.length;
  const moderateDroughtYears = years.filter((_, i) => annualPrecip[i] < avgPrecip * 0.74);
  const severeDroughtYears = years.filter((_, i) => annualPrecip[i] < avgPrecip * 0.5);
  
  // Generate monthly precipitation data
  const monthlyPrecip = Array(12).fill().map(() => 20 + Math.random() * 100);
  
  // Generate frost comparison data
  const currentYearTemps = Array(12).fill().map(() => baseTemp + Math.random() * 10 - 5);
  const historicalTemps = Array(12).fill().map(() => baseTemp + Math.random() * 8 - 4);
  
  // Generate frost months data
  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  const frostMonths = monthNames.map((name, index) => {
    const frostDays = (index >= 4 && index <= 8) ? Math.floor(Math.random() * 5) : 0;
    return {
      name: name,
      frostDays: frostDays,
      hasFrost: frostDays > 0
    };
  });
  
  // Determine frost risk level
  const currentFrostDays = annualFrostDays[annualFrostDays.length - 1];
  let frostRisk = 'Low';
  if (currentFrostDays > 15) frostRisk = 'High';
  else if (currentFrostDays > 8) frostRisk = 'Moderate';
  
  // Determine coldest month
  const coldestMonthIndex = monthlyPrecip.indexOf(Math.min(...monthlyPrecip));
  const coldestMonth = monthNames[coldestMonthIndex];
  
  // Prepare data structure
  return {
    location: {
      coords: `${lat}, ${lon}`,
      name: currentLocationName
    },
    temp: {
      labels: yearLabels,
      values: annualAvgTemp
    },
    precip: {
      labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      values: monthlyPrecip
    },
    annualRainfall: {
      labels: yearLabels,
      values: annualPrecip
    },
    frost: {
      labels: yearLabels,
      values: annualFrostDays
    },
    drought: {
      labels: yearLabels,
      values: annualPrecip.map(p => parseFloat(((p - avgPrecip) / avgPrecip * 100).toFixed(1)))
    },
    frostComparison: {
      labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      currentTemps: currentYearTemps,
      historicalTemps: historicalTemps
    },
    plantingDates: plantingDates, // Include sample planting dates
    stats: {
      avgTemp: (annualAvgTemp.reduce((a, b) => a + b, 0) / annualAvgTemp.length).toFixed(1),
      maxTemp: (Math.max(...annualAvgTemp) + 10).toFixed(1),
      minTemp: (Math.min(...annualAvgTemp) - 15).toFixed(1),
      warming: warmingTrend,
      annualPrecip: avgPrecip.toFixed(1),
      maxMonthlyPrecip: Math.max(...monthlyPrecip).toFixed(1),
      drySpells: (monthlyPrecip.filter(p => p < 30).length / years.length).toFixed(1),
      precipTrend: precipTrend,
      highFrostYears: highFrostYears,
      moderateDroughtYears: moderateDroughtYears,
      severeDroughtYears: severeDroughtYears,
      totalFrost: currentFrostDays,
      avgFrost: (annualFrostDays.reduce((a, b) => a + b, 0) / annualFrostDays.length).toFixed(1),
      coldestMonth: coldestMonth,
      frostRisk: frostRisk,
      frostMonths: frostMonths
    },
    prediction: {
      year: new Date().getFullYear() + 1,
      temp: parseFloat(annualAvgTemp[annualAvgTemp.length - 1] + (warmingTrend / years.length)).toFixed(1),
      precip: Math.max(0, parseFloat(annualPrecip[annualPrecip.length - 1] * (1 + precipTrend / 100 / years.length)).toFixed(0)),
      frost: Math.max(0, annualFrostDays[annualFrostDays.length - 1] + Math.round(warmingTrend / 10))
    }
  };
}
</script>
</html>
